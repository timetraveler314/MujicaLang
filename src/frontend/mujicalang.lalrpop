grammar;

use crate::frontend::ast::*;

// Lexical
match {
    r"\s*" => {}, // skip whitespace
    _
}

pub Expr: ASTExpr = {
    #[precedence(level="1")]
    IfExpr,
    #[precedence(level="1")]
    LetExpr,
    // Lambdas bind the weakest
    #[precedence(level="10")]
    "fun" <args: OptionallyTypedIdent+> "->" <body: Expr> => {
        // Currying
        args.into_iter().rfold(
            body,
            |acc, arg| ASTExpr::Lambda {
                arg: arg,
                body: Box::new(acc),
            },
        )
    },
    #[precedence(level="1")]
    ApplyExpr,
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => curry_binop!(OpType::Mul, l, r),
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "/" <r:Expr> => curry_binop!(OpType::Div, l, r),
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => curry_binop!(OpType::Add, l, r),
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "-" <r:Expr> => curry_binop!(OpType::Sub, l, r),
    #[precedence(level="4")] #[assoc(side="left")]
    <l:Expr> "==" <r:Expr> => curry_binop!(OpType::Eq, l, r),
}

IfExpr: ASTExpr = {
    "if" <cond: Expr> "then" <then: Expr> "else" <else_: Expr> "end" => ASTExpr::If {
        cond: Box::new(cond),
        then: Box::new(then),
        else_: Box::new(else_),
    },
}

LetExpr: ASTExpr = {
    "let" <bind: OptionallyTypedIdent> "=" <value: Expr> "in" <body: Expr> "end" => ASTExpr::Let {
        bind,
        value: Box::new(value),
        body: Box::new(body),
    },
}

LambdaExpr: ASTExpr = {
    "fun" <args: OptionallyTypedIdent+> "->" <body: Expr> => {
        // Currying
        args.into_iter().rfold(
            body,
            |acc, arg| ASTExpr::Lambda {
                arg: arg,
                body: Box::new(acc),
            },
        )
    }
}

ApplyExpr: ASTExpr = {
    <callee: ApplyExpr> <arg: Atom> => ASTExpr::Apply(Box::new(callee), Box::new(arg)),
    <atom: Atom> => atom,
}

Atom: ASTExpr = {
    <ident: Ident> => ASTExpr::Atom(ASTAtom::Var(ident)),
    <num: Int> => ASTExpr::Atom(ASTAtom::Int(num)),
    "(" <expr: Expr> ")" => expr,
}

OptionallyTypedIdent: OptionallyTypedIdent = {
//    "(" <ident: Ident> ":" <typ: Type> ")" => OptionallyTypedIdent::new(ident, Some(typ)),
    <ident: Ident> => OptionallyTypedIdent::new(ident, None),
}

Ident: String = {
    <s:r"[a-z_][a-zA-Z0-9_]*"> => s.to_string(),
};

Int: i32 = {
    <n:r"-?[0-9]+"> => i32::from_str_radix(n, 10).unwrap(),
};